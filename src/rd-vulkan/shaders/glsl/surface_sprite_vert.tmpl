#version 450
// based on OpenJK rend2 surface_sprites.glsl

#ifdef USE_FOG
	layout (constant_id = 0) const int hw_fog = 0;
#endif
layout (constant_id = 1) const int kFaceCamera = 0;
layout (constant_id = 2) const int kFaceUp = 0;
layout (constant_id = 3) const int kFaceFlattened = 0;
layout (constant_id = 4) const int kFxSprite = 0;
layout (constant_id = 5) const int kAdditive = 0;
layout (constant_id = 6) const int kUseFog = 0;

// 64 bytes
layout(push_constant) uniform Transform {
	mat4 mvp;
};

#if defined(USE_FOG)
layout(set = 0, binding = 0) uniform UBO {
	// light/env/material parameters:
	vec4 eyePos;
	vec4 lightPos;
	vec4 lightColor;
	vec4 lightVector;
	
	// fog parameters:
	vec4 fogDistanceVector;
	vec4 fogDepthVector;
	vec4 fogEyeT;
	vec4 fogColor;

};
#endif

layout(set = 0, binding = 1) uniform Camera {
	vec4 u_ViewOrigin;
};

layout(set = 1, binding = 0) buffer SurfaceSprite
{
	vec2  u_FxGrow;
	float u_FxDuration;
	float u_FadeStartDistance;
	float u_FadeEndDistance;
	float u_FadeScale;
	float u_Wind;
	float u_WindIdle;
	float u_FxAlphaStart;
	float u_FxAlphaEnd;
};

layout(location = 0) in uint in_vertex_id;	// unused
layout(location = 1) in vec4 in_position;
layout(location = 2) in vec3 in_normal;
layout(location = 3) in vec4 in_color;
layout(location = 4) in vec2 in_width_height;
layout(location = 5) in vec2 in_skew;

layout(location = 0) out vec4 frag_color0;
layout(location = 1) out vec2 frag_tex_coord0;
layout(location = 2) out float var_Effectpos;
#ifdef USE_FOG
layout(location = 3) out vec3 fog_tex_coord;	// or ws_worldpos
#endif

out gl_PerVertex {
	vec4 gl_Position;
};

void main() {
	vec3 V = u_ViewOrigin.xyz - in_position.rgb;

	float width = in_width_height.x;
	float height = in_width_height.y;
	vec2 skew = in_skew.xy;

	float distanceToCamera = length( V );
	float fadeScale = smoothstep( u_FadeStartDistance, u_FadeEndDistance, distanceToCamera );
	width += u_FadeScale * fadeScale * width;

	if ( kFxSprite > 0 ) {
		//float sprite_time = u_frameTime * 1000.0;
		float sprite_time = u_ViewOrigin.w * 1000.0;
		var_Effectpos = fract((sprite_time+10000.0 * in_position.w) / u_FxDuration);
		width += var_Effectpos * width * u_FxGrow.x;
		height += var_Effectpos * height * u_FxGrow.y;
	}

	float halfWidth = width * 0.5;

	vec3 offsets[4];

	if ( kFaceUp > 0 ) {
		offsets[0] = vec3( halfWidth, -halfWidth, 0.0);
		offsets[1] = vec3( halfWidth,  halfWidth, 0.0);
		offsets[2] = vec3(-halfWidth,  halfWidth, 0.0);
		offsets[3] = vec3(-halfWidth, -halfWidth, 0.0);
	} else {
		offsets[0] = vec3( halfWidth, 0.0, 0.0);
		offsets[1] = vec3( halfWidth, 0.0, height);
		offsets[2] = vec3(-halfWidth, 0.0, height);
		offsets[3] = vec3(-halfWidth, 0.0, 0.0);
	}

	const vec2 texcoords[] = vec2[](
		vec2(1.0, 1.0),
		vec2(1.0, 0.0),
		vec2(0.0, 0.0),
		vec2(0.0, 1.0)
	);

	#if 0
		// prototyping with non-indexed indirect with vertexCount 6
		// work fine, but having a VBO and IBO is more flexible and 
		// using GPU fixed-function index fetching might be more performant
		//const int idxs[6] = int[6](0, 1, 2, 2, 3, 0);
		//int idx = idxs[gl_VertexIndex];
	#endif
	//int idx = gl_VertexIndex % 4;
	int idx = gl_VertexIndex & 3;

	vec3 offset = offsets[idx];

	if ( kFaceCamera > 0 )
	{
		vec2 toCamera = normalize(V.xy);
		offset.xy = offset.x*vec2(toCamera.y, -toCamera.x);
	}
	else if ( kFaceFlattened > 0 )
	{
		// Make this sprite face in some direction
		offset.xy = offset.x * in_normal.xy;
	}
	else if ( kFaceUp == 0 )
	{
		// Make this sprite face in some direction in direction of the camera
		vec2 toCamera = normalize(V.xy);
		offset.xy = offset.x * (in_normal.xy + 3.0 * vec2(toCamera.y, -toCamera.x)) * 0.25;
	}

	if ( kFaceUp == 0 && kFxSprite == 0 )
	{
		float isLowerVertex = float(offset.z == 0.0);
		offset.xy += mix(skew, vec2(0.0), isLowerVertex);
		//float sprite_time = u_frameTime * 1000.0;
		float sprite_time = u_ViewOrigin.w * 1000.0;
		float angle = (in_position.x + in_position.y) * 0.02 + (sprite_time * 0.0015);
		float windsway = mix(height* u_WindIdle * 0.075, 0.0, isLowerVertex);
		offset.xy += vec2(cos(angle), sin(angle)) * windsway;
	}

	vec4 worldPos = vec4(in_position.xyz + offset, 1.0);
	vec3 normal = normalize( in_normal );

	gl_Position = mvp * worldPos;
	frag_color0.rgb = in_color.rgb;
	frag_tex_coord0 = texcoords[idx];

#ifdef USE_FOG	
	if ( hw_fog == 1 ) 
	{
		fog_tex_coord = worldPos.xyz;
	}
	else 
	{
		float s = dot(worldPos.xyz, fogDistanceVector.xyz) + fogDistanceVector.w;
		float t = dot(worldPos.xyz, fogDepthVector.xyz) + fogDepthVector.w;

		if ( fogEyeT.y == 1.0 ) {
			if ( t < 0.0 ) {
				t = 1.0 / 32.0;
			} else {
				t = 31.0 / 32.0;
			}
		} else {
			if ( t < 1.0 ) {
				t = 1.0 / 32.0;
			} else {
				t = 1.0 / 32.0 + (30.0 / 32.0 * t) / ( t - fogEyeT.x );
			}
		}

		fog_tex_coord.xy = vec2(s, t);
	}
#endif
}